<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="Dubbo, Consistent Hash，一致性Hash，一致性哈希" />
	<meta name="description" content="本文以一般的一致性Hash实现作为引子，详细剖析了Dubbo一致性Hash负载均衡算法的实现" />
	<!-- 网页标签标题 -->
	<title>Dubbo一致性Hash负载均衡实现剖析</title>
	<link rel="shortcut icon" href="/img/dubbo.ico"/>
	<link rel="stylesheet" href="/build/blogDetail.css" />
</head>
<body>
	<div id="root"><div class="blog-detail-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/zh-cn/index.html"><img class="logo" src="/img/dubbo_colorful.png"/></a><div class="search search-normal"><span class="icon-search"></span></div><span class="language-switch language-switch-normal">En</span><div class="header-menu"><img class="header-menu-toggle" src="/img/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="/zh-cn/index.html">首页</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/docs/user/quick-start.html">文档</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/docs/developers/developers_dev.html">开发者</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/zh-cn/blog/index.html">博客</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/community/index.html">社区</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/ecology/index.html">生态系统</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/download.html">下载</a></li></ul></div></div></header><section class="blog-content markdown-body"><p>需要强调的是，Dubbo的Hash映射模型与大部分网上资料描述的<strong>环形队列Hash映射模型</strong>是存在一些区别的。于我而言，环形队列Hash映射模型，不足以让我对一致性Hash有足够彻底的了解。直到看懂了Dubbo的一致性Hash的实现，才觉得豁然开朗。</p>
<h3>一、环形队列Hash映射模型</h3>
<p>这种方案，其基础还是基于取模运算。对2^32取模，那么，Hash值的区间为[0, 2^32-1]。接下来要做的，就包括两部分：</p>
<h4><strong>a、映射服务</strong></h4>
<p>将服务地址（ip+端口）按照一定规则构造出特定的识别码（如md5码），再用识别码对2^32取模，确定服务在Hash值区间对应的位置。假设有Node1、Node2、Node3三个服务，其映射关系如下：</p>
<p><img src="../../img/blog/consistenthash/consistent-hash-init-model.jpg" alt="Init"></p>
<h4><strong>b、映射请求、定位服务</strong></h4>
<p>在发起请求时，我们往往会带上参数，而这些参数，就可以被我们用来确定具体调用哪一个服务。假设有请求R1、R2、R3，对它们的参数也经过计算特定识别码、取余的一系列运算之后，有如下映射关系：</p>
<p><img src="../../img/blog/consistenthash/consistent-hash-request-model.jpg" alt="Request"></p>
<p>从图中，我们可以看到，R1请求映射在0-Node1中间，R2请求映射在Node1-Node2中间，R3请求映射在Node2-Node3中间。我们取<strong>服务Hash值大于请求Hash值</strong>的<strong>第一个服务</strong>作为实际的调用服务。也就是说，R1请求将调用Node1服务，R2请求将调用Node2服务，R3请求将调用Node3服务。</p>
<h4><strong>c、新增服务节点</strong></h4>
<p>假设新增服务Node4，映射在Node3之前，恰巧破坏了原来的一个映射关系：</p>
<p><img src="../../img/blog/consistenthash/consistent-hash-new-node-model.jpg" alt="New Node"></p>
<p>这样，请求R3将会实际调用服务Node4，但请求R1、R2不受影响。</p>
<h4><strong>d、删除服务节点</strong></h4>
<p>假设服务Node2宕机，那么R2请求将会映射到Node3：</p>
<p><img src="../../img/blog/consistenthash/consistent-hash-delete-node-model.jpg" alt="Delete Node"></p>
<p>原本的R1、R3请求不受影响。</p>
<blockquote>
<p>可以看出，当新增、删除服务时，受影响的请求是有限的。不至于像简单取模映射一般，服务发生变化时，需要调整全局的映射关系。</p>
</blockquote>
<h4><strong>e、平衡性与虚拟节点</strong></h4>
<p>在我们上面的假设中，我们假设Node1、Node2、Node3三个服务在经过Hash映射后所分布的位置恰巧把环切成了均等的三分，请求的分布也基本是平衡的。但是实际上计算服务Hash值的时候，是很难这么巧的。也许一不小心就映射成了这个样子：</p>
<p><img src="../../img/blog/consistenthash/consistent-hash-balance-model.jpg" alt="Balance"></p>
<p>这样，就会导致大部分请求都会被映射到Node1上。因此，引出了虚拟节点。</p>
<p>所谓虚拟节点，就是除了对服务本身地址进行Hash映射外，还通过在它地址上做些处理（比如Dubbo中，在ip+port的字符串后加上计数符1、2、3......，分别代表虚拟节点1、2、3），以达到同一服务映射多个节点的目的。通过引入虚拟节点，我们可以把上图中映射给Node1的请求进一步拆分：</p>
<p><img src="../../img/blog/consistenthash/consistent-hash-virtual-node-model.jpg" alt="Virtual Node"></p>
<p>如上图所示，若有请求落在Node3-Node1'区间，该请求应该是调用Node1'服务，但是因为Node1'是Node1的虚拟节点，所以实际调用的是Node1服务。通过引入虚拟节点，请求的分布就会比较平衡了。</p>
<h3><strong>二、Dubbo一致性Hash的使用与负载均衡策略的引入阶段</strong></h3>
<h4><strong>a、如何使用一致性Hash作为Dubbo的负载均衡策略？</strong></h4>
<p>dubbo:service、dubbo:reference、dubbo:provider、dubbo:consumer、dubbo:method这几个配置项都可以配置Dubbo的负载均衡策略，其中一致性Hash的属性值是：<strong>consistenthash</strong>。</p>
<p>以dubbo:reference为例：</p>
<p><strong>XML配置：</strong></p>
<blockquote>
<p>&lt;dubbo:reference loadbalance=&quot;consistenthash&quot; /&gt;</p>
</blockquote>
<p><strong>Properties配置：</strong></p>
<blockquote>
<p>dubbo.reference.loadbalance=consistenthash</p>
</blockquote>
<p><strong>注解：</strong></p>
<blockquote>
<p>@Reference(loadbalance = &quot;consistenthash&quot;)</p>
</blockquote>
<h4><strong>b、Dubbo负载均衡策略的引入阶段</strong></h4>
<p>Dubbo实现的是客户端负载均衡。关于服务接口代理类的实现，这里不做详细描述，可以参考官网：</p>
<blockquote>
<p>服务引入：<a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/refer-service.html%E3%80%82">http://dubbo.apache.org/zh-cn/docs/source_code_guide/refer-service.html。</a></p>
</blockquote>
<p>在接口代理类生成、并且装配好后，服务的调用基本是这样一个流程：proxy -&gt; MockClusterInvoker -&gt; 集群策略（如：FailoverClusterInvoker） -&gt; 初始化负载均衡策略 -&gt; 根据选定的负载均衡策略确定Invoker。</p>
<p><strong>负载均衡策略的初始化</strong>是在AbstractClusterInvoker中的initLoadBalance方法中初始化的：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">protected</span> LoadBalance <span class="hljs-title">initLoadBalance</span><span class="hljs-params">(List&lt;Invoker&lt;T&gt;&gt; invokers, Invocation invocation)</span> </span>{
    <span class="hljs-keyword">if</span> (CollectionUtils.isNotEmpty(invokers)) {
        <span class="hljs-keyword">return</span> ExtensionLoader.getExtensionLoader(LoadBalance<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">getExtension</span>(<span class="hljs-title">invokers</span>.<span class="hljs-title">get</span>(0).<span class="hljs-title">getUrl</span>()
                .<span class="hljs-title">getMethodParameter</span>(<span class="hljs-title">RpcUtils</span>.<span class="hljs-title">getMethodName</span>(<span class="hljs-title">invocation</span>), <span class="hljs-title">LOADBALANCE_KEY</span>, <span class="hljs-title">DEFAULT_LOADBALANCE</span>))</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> ExtensionLoader.getExtensionLoader(LoadBalance<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">getExtension</span>(<span class="hljs-title">DEFAULT_LOADBALANCE</span>)</span>;
    }
}
</code></pre>
<p>这部分代码逻辑分为两部分：</p>
<p>1、获取调用方法所配置的LOADBALANCE_KEY属性的值，LOADBALANCE_KEY这个常量的实际值为：loadbalance，即为我们的所配置的属性；</p>
<p>2、利用SPI机制来初始化并加载该值所代表的负载均衡策略。</p>
<p>所有的负载均衡策略都会继承LoadBalance接口。在各种集群策略中，最终都会调用AbstractClusterInvoker的select方法，而AbstractClusterInvoker会在doSelect中，<strong>调用LoadBalance的select方法，这里即开始了负载均衡策略的执行。</strong></p>
<h3>三、Dubbo一致性Hash负载均衡的实现</h3>
<p>需要说明的一点是，我所说的<strong>负载均衡策略的执行</strong>，即是在所有的Provider中选出一个，作为当前Consumer的远程调用对象。在代码中，Provider被封装成了Invoker实体，所以直接说来，负载均衡策略的执行就是在Invoker列表中选出一个Invoker。</p>
<p>所以，对比普通一致性Hash的实现，Dubbo的一致性Hash算法也可以分为两步：</p>
<p><strong>1、映射Provider至Hash值区间中（实际中映射的是Invoker）；</strong></p>
<p><strong>2、映射请求，然后找到大于请求Hash值的第一个Invoker。</strong></p>
<h4><strong>a、映射Invoker</strong></h4>
<p>Dubbo中所有的负载均衡实现类都继承了AbstractLoadBalance，调用LoadBalance的select方法时，实际上调用的是AbstractLoadBalance的实现：</p>
<pre><code class="language-java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">select</span><span class="hljs-params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>{
    <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(invokers)) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
    <span class="hljs-keyword">if</span> (invokers.size() == <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> invokers.get(<span class="hljs-number">0</span>);
    }
    <span class="hljs-comment">// doSelect这里进入具体负载均衡算法的执行逻辑</span>
    <span class="hljs-keyword">return</span> doSelect(invokers, url, invocation);
}
</code></pre>
<p>可以看到这里调用了doSelect，Dubbo一致性Hash的具体实现类名字是<strong>ConsistentHashLoadBalance</strong>，让我们来看看它的doSelect方法干了啥：</p>
<pre><code class="language-java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">doSelect</span><span class="hljs-params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>{
    String methodName = RpcUtils.getMethodName(invocation);
    <span class="hljs-comment">// key格式：接口名.方法名</span>
    String key = invokers.get(<span class="hljs-number">0</span>).getUrl().getServiceKey() + <span class="hljs-string">"."</span> + methodName;
    <span class="hljs-comment">// identityHashCode 用来识别invokers是否发生过变更</span>
    <span class="hljs-keyword">int</span> identityHashCode = System.identityHashCode(invokers);
    ConsistentHashSelector&lt;T&gt; selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);
    <span class="hljs-keyword">if</span> (selector == <span class="hljs-keyword">null</span> || selector.identityHashCode != identityHashCode) {
        <span class="hljs-comment">// 若不存在"接口.方法名"对应的选择器，或是Invoker列表已经发生了变更，则初始化一个选择器</span>
        selectors.put(key, <span class="hljs-keyword">new</span> ConsistentHashSelector&lt;T&gt;(invokers, methodName, identityHashCode));
        selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);
    }
    <span class="hljs-keyword">return</span> selector.select(invocation);
}
</code></pre>
<p>这里有个很重要的概念：<strong>选择器——selector</strong>。这是Dubbo一致性Hash实现中，承载着整个映射关系的数据结构。它里面主要有这么几个参数：</p>
<pre><code class="language-java"><span class="hljs-comment">/**
 * 存储Hash值与节点映射关系的TreeMap
 */</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TreeMap&lt;Long, Invoker&lt;T&gt;&gt; virtualInvokers;

<span class="hljs-comment">/**
 * 节点数目
 */</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> replicaNumber;

<span class="hljs-comment">/**
 * 用来识别Invoker列表是否发生变更的Hash码
 */</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> identityHashCode;

<span class="hljs-comment">/**
 * 请求中用来作Hash映射的参数的索引
 */</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] argumentIndex;
</code></pre>
<p>在新建ConsistentHashSelector对象的时候，就会遍历所有Invoker对象，然后计算出其地址（ip+port）对应的md5码，并按照配置的节点数目replicaNumber的值来初始化服务节点和所有虚拟节点：</p>
<pre><code class="language-java">ConsistentHashSelector(List&lt;Invoker&lt;T&gt;&gt; invokers, String methodName, <span class="hljs-keyword">int</span> identityHashCode) {
    <span class="hljs-keyword">this</span>.virtualInvokers = <span class="hljs-keyword">new</span> TreeMap&lt;Long, Invoker&lt;T&gt;&gt;();
    <span class="hljs-keyword">this</span>.identityHashCode = identityHashCode;
    URL url = invokers.get(<span class="hljs-number">0</span>).getUrl();
    <span class="hljs-comment">// 获取配置的节点数目</span>
    <span class="hljs-keyword">this</span>.replicaNumber = url.getMethodParameter(methodName, HASH_NODES, <span class="hljs-number">160</span>);
    <span class="hljs-comment">// 获取配置的用作Hash映射的参数的索引</span>
    String[] index = COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, HASH_ARGUMENTS, <span class="hljs-string">"0"</span>));
    argumentIndex = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[index.length];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index.length; i++) {
        argumentIndex[i] = Integer.parseInt(index[i]);
    }
    <span class="hljs-comment">// 遍历所有Invoker对象</span>
    <span class="hljs-keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) {
        <span class="hljs-comment">// 获取Provider的ip+port</span>
        String address = invoker.getUrl().getAddress();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; replicaNumber / <span class="hljs-number">4</span>; i++) {
            <span class="hljs-keyword">byte</span>[] digest = md5(address + i);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> h = <span class="hljs-number">0</span>; h &lt; <span class="hljs-number">4</span>; h++) {
                <span class="hljs-keyword">long</span> m = hash(digest, h);
                virtualInvokers.put(m, invoker);
            }
        }
    }
}
</code></pre>
<p>这里值得注意的是：以replicaNumber取默认值160为例，假设当前遍历到的Invoker地址为127.0.0.1:20880，它会依次获得“127.0.0.1:208800”、“127.0.0.1:208801”、......、“127.0.0.1:2088040”的md5摘要，在每次获得摘要之后，还会对该摘要进行四次数位级别的散列。大致可以猜到其目的应该是为了加强散列效果。（希望有人能告诉我相关的理论依据。）</p>
<p>代码中**virtualInvokers.put(m, invoker)**即是存储当前计算出的Hash值与Invoker的映射关系。</p>
<p>这段代码简单说来，就是为每个Invoker都创建replicaNumber个节点，Hash值与Invoker的映射关系即象征着一个节点，这个关系存储在TreeMap中。</p>
<h4><strong>b、映射请求</strong></h4>
<p>让我们重新回到ConsistentHashLoadBalance的<strong>doSelect</strong>方法，若没有找到selector则会新建selector，找到selector后便会调用selector的select方法：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> Invoker&lt;T&gt; <span class="hljs-title">select</span><span class="hljs-params">(Invocation invocation)</span> </span>{
    <span class="hljs-comment">// 根据invocation的【参数值】来确定key，默认使用第一个参数来做hash计算</span>
    String key = toKey(invocation.getArguments());
    <span class="hljs-comment">//  获取【参数值】的md5编码</span>
    <span class="hljs-keyword">byte</span>[] digest = md5(key);
    <span class="hljs-keyword">return</span> selectForKey(hash(digest, <span class="hljs-number">0</span>));
}

<span class="hljs-comment">// 根据参数索引获取参数，并将所有参数拼接成字符串</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">toKey</span><span class="hljs-params">(Object[] args)</span> </span>{
    StringBuilder buf = <span class="hljs-keyword">new</span> StringBuilder();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : argumentIndex) {
        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; args.length) {
            buf.append(args[i]);
        }
    }
    <span class="hljs-keyword">return</span> buf.toString();
}

<span class="hljs-comment">// 根据参数字符串的md5编码找出Invoker</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> Invoker&lt;T&gt; <span class="hljs-title">selectForKey</span><span class="hljs-params">(<span class="hljs-keyword">long</span> hash)</span> </span>{
    Map.Entry&lt;Long, Invoker&lt;T&gt;&gt; entry = virtualInvokers.ceilingEntry(hash);
    <span class="hljs-keyword">if</span> (entry == <span class="hljs-keyword">null</span>) {
        entry = virtualInvokers.firstEntry();
    }
    <span class="hljs-keyword">return</span> entry.getValue();
}
</code></pre>
<p>argumentIndex是在初始化Selector的时候一起赋值的，代表着需要用哪几个请求参数作Hash映射获取Invoker。比如：有方法methodA(Integer a, Integer b, Integer c)，如果argumentIndex的值为{0,2}，那么即用a和c拼接的字符串来计算Hash值。</p>
<p>我们已经知道virtualInvokers是一个TreeMap，TreeMap的底层实现是红黑树。对于TreeMap的方法ceilingEntry(hash)，它的作用是用来<strong>获取比传入值大的第一个元素</strong>。可以看到，这一点与一般的一致性Hash算法的处理逻辑完全是相同的。</p>
<p>但这里的回环逻辑有点不同。对于取模运算来讲，大于最大值后，会自动回环从0开始，而这里的逻辑是：当没有比传入ceilingEntry()方法中的值大的元素的时候，virtualInvokers.ceilingEntry(hash)必然会得到null，于是，就用virtualInvokers.firstEntry()来获取整个TreeMap的第一个元素。</p>
<p>从selectForKey中获取到Invoker后，负载均衡策略也就算是执行完毕了。后续获取远程调用客户端等调用流程不再赘述。</p>
</section><footer class="footer-container"><div class="footer-body"><img src="/img/dubbo_gray.png"/><img class="apache" src="/img/apache_logo.png"/><div class="cols-container"><div class="col col-12"><h3></h3><p></p></div><div class="col col-4"><dl><dt>ASF</dt><dd><a href="http://www.apache.org" target="_self">基金会</a></dd><dd><a href="http://www.apache.org/licenses/" target="_self">证书</a></dd><dd><a href="http://www.apache.org/events/current-event" target="_self">事件</a></dd><dd><a href="http://www.apache.org/foundation/sponsorship.html" target="_self">赞助</a></dd><dd><a href="http://www.apache.org/foundation/thanks.html" target="_self">致谢</a></dd></dl></div><div class="col col-4"><dl><dt>文档</dt><dd><a href="/zh-cn/docs/user/quick-start.html" target="_self">快速开始</a></dd><dd><a href="/zh-cn/docs/dev/build.html" target="_self">开发者指南</a></dd><dd><a href="/zh-cn/docs/admin/ops/dubbo-ops.html" target="_self">运维管理</a></dd><dd><a href="https://github.com/apache/dubbo-website/issues/new" target="_self">报告文档问题</a></dd><dd><a href="https://github.com/apache/dubbo-website" target="_self">编辑此文档</a></dd></dl></div><div class="col col-4"><dl><dt>资源</dt><dd><a href="/zh-cn/blog/index.html" target="_self">博客</a></dd><dd><a href="/zh-cn/community/index.html" target="_self">社区</a></dd><dd><a href="https://www.apache.org/security" target="_self">安全</a></dd></dl></div></div><div class="copyright"><span>Copyright © 2018-2019 The Apache Software Foundation. Apache and the Apache feather logo are trademarks of The Apache Software Foundation.</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
  <script src="/build/blogDetail.js"></script>
  <!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-112489517-1"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-112489517-1');
	</script>
</body>
</html>